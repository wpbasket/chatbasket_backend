// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: personal_user.sql

package postgresCode

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createAloneUsername = `-- name: CreateAloneUsername :one
INSERT INTO alone_username (
    id,
    username
)
VALUES ($1, $2)
RETURNING id, username, created_at, updated_at
`

type CreateAloneUsernameParams struct {
	ID       uuid.UUID `json:"id"`
	Username string    `json:"username"`
}

func (q *Queries) CreateAloneUsername(ctx context.Context, arg CreateAloneUsernameParams) (AloneUsername, error) {
	row := q.db.QueryRow(ctx, createAloneUsername, arg.ID, arg.Username)
	var i AloneUsername
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createAvatar = `-- name: CreateAvatar :one
INSERT INTO avatars (
    id,
    user_id,
    file_id,
    avatar_type,
    token_id,
    token_secret,
    token_expiry
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, file_id, avatar_type, token_id, token_secret, token_expiry, created_at, updated_at
`

type CreateAvatarParams struct {
	ID          uuid.UUID          `json:"id"`
	UserID      uuid.UUID          `json:"user_id"`
	FileID      string             `json:"file_id"`
	AvatarType  string             `json:"avatar_type"`
	TokenID     *string            `json:"token_id"`
	TokenSecret *string            `json:"token_secret"`
	TokenExpiry pgtype.Timestamptz `json:"token_expiry"`
}

// Inserts a new avatar and returns all columns
func (q *Queries) CreateAvatar(ctx context.Context, arg CreateAvatarParams) (Avatar, error) {
	row := q.db.QueryRow(ctx, createAvatar,
		arg.ID,
		arg.UserID,
		arg.FileID,
		arg.AvatarType,
		arg.TokenID,
		arg.TokenSecret,
		arg.TokenExpiry,
	)
	var i Avatar
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FileID,
		&i.AvatarType,
		&i.TokenID,
		&i.TokenSecret,
		&i.TokenExpiry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one

INSERT INTO users (
    id,
    name,
    b64_cipher_chacha20poly1305_username,
    hmac_sha256_hex_username,
    profile_type
)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, bio, contacts, profile_type, is_admin_blocked, admin_block_reason, hmac_sha256_hex_username, b64_cipher_chacha20poly1305_username, created_at, updated_at
`

type CreateUserParams struct {
	ID                                uuid.UUID `json:"id"`
	Name                              string    `json:"name"`
	B64CipherChacha20poly1305Username string    `json:"b64_cipher_chacha20poly1305_username"`
	HmacSha256HexUsername             string    `json:"hmac_sha256_hex_username"`
	ProfileType                       string    `json:"profile_type"`
}

// ======================================
// Users Table Queries for sqlc
// ======================================
// Inserts a new user and returns all columns
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Name,
		arg.B64CipherChacha20poly1305Username,
		arg.HmacSha256HexUsername,
		arg.ProfileType,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Bio,
		&i.Contacts,
		&i.ProfileType,
		&i.IsAdminBlocked,
		&i.AdminBlockReason,
		&i.HmacSha256HexUsername,
		&i.B64CipherChacha20poly1305Username,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAvatar = `-- name: DeleteAvatar :exec
DELETE FROM avatars
WHERE user_id = $1 AND file_id = $1::TEXT
`

// Deletes the main profile avatar for a user
func (q *Queries) DeleteAvatar(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteAvatar, userID)
	return err
}

const getUserProfile = `-- name: GetUserProfile :many
SELECT 
    u.id, u.name, u.bio, u.contacts, u.profile_type, u.is_admin_blocked, u.admin_block_reason, u.hmac_sha256_hex_username, u.b64_cipher_chacha20poly1305_username, u.created_at, u.updated_at, 
    a.file_id,
    a.token_id,
    a.token_secret,
    a.token_expiry
FROM users u
LEFT JOIN avatars a 
    ON a.user_id = u.id 
    AND a.file_id = u.id::TEXT   -- main profile avatar (file_id == user_id)
WHERE u.id = $1
`

type GetUserProfileRow struct {
	ID                                uuid.UUID          `json:"id"`
	Name                              string             `json:"name"`
	Bio                               *string            `json:"bio"`
	Contacts                          int32              `json:"contacts"`
	ProfileType                       string             `json:"profile_type"`
	IsAdminBlocked                    bool               `json:"is_admin_blocked"`
	AdminBlockReason                  *string            `json:"admin_block_reason"`
	HmacSha256HexUsername             string             `json:"hmac_sha256_hex_username"`
	B64CipherChacha20poly1305Username string             `json:"b64_cipher_chacha20poly1305_username"`
	CreatedAt                         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt                         pgtype.Timestamptz `json:"updated_at"`
	FileID                            *string            `json:"file_id"`
	TokenID                           *string            `json:"token_id"`
	TokenSecret                       *string            `json:"token_secret"`
	TokenExpiry                       pgtype.Timestamptz `json:"token_expiry"`
}

// Returns full user record along with its profile avatar tokens and file_id
func (q *Queries) GetUserProfile(ctx context.Context, id uuid.UUID) ([]GetUserProfileRow, error) {
	rows, err := q.db.Query(ctx, getUserProfile, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserProfileRow
	for rows.Next() {
		var i GetUserProfileRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Bio,
			&i.Contacts,
			&i.ProfileType,
			&i.IsAdminBlocked,
			&i.AdminBlockReason,
			&i.HmacSha256HexUsername,
			&i.B64CipherChacha20poly1305Username,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FileID,
			&i.TokenID,
			&i.TokenSecret,
			&i.TokenExpiry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserExists = `-- name: IsUserExists :one
SELECT EXISTS(
    SELECT 1
    FROM users
    WHERE id = $1
)
`

func (q *Queries) IsUserExists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isUserExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isUserProfilePicExists = `-- name: IsUserProfilePicExists :one
SELECT EXISTS(
    SELECT 1
    FROM users u
    JOIN avatars a ON a.user_id = u.id
    WHERE u.id = $1
    AND a.file_id = u.id::TEXT
)
`

// Checks if the user exists and has a main profile picture
func (q *Queries) IsUserProfilePicExists(ctx context.Context, id uuid.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isUserProfilePicExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listUsersAfter = `-- name: ListUsersAfter :many
SELECT id, name, bio, contacts, profile_type, is_admin_blocked, admin_block_reason, hmac_sha256_hex_username, b64_cipher_chacha20poly1305_username, created_at, updated_at
FROM users
WHERE created_at < $1
ORDER BY created_at DESC
LIMIT $2
`

type ListUsersAfterParams struct {
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	Limit     int32              `json:"limit"`
}

// Returns users created before a certain timestamp (keyset pagination)
func (q *Queries) ListUsersAfter(ctx context.Context, arg ListUsersAfterParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsersAfter, arg.CreatedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Bio,
			&i.Contacts,
			&i.ProfileType,
			&i.IsAdminBlocked,
			&i.AdminBlockReason,
			&i.HmacSha256HexUsername,
			&i.B64CipherChacha20poly1305Username,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAvatarTokens = `-- name: UpdateAvatarTokens :one
UPDATE avatars
SET token_id = $2, token_secret = $3, token_expiry = $4
WHERE user_id = $1 AND file_id = $1::TEXT
RETURNING id, user_id, file_id, avatar_type, token_id, token_secret, token_expiry, created_at, updated_at
`

type UpdateAvatarTokensParams struct {
	UserID      uuid.UUID          `json:"user_id"`
	TokenID     *string            `json:"token_id"`
	TokenSecret *string            `json:"token_secret"`
	TokenExpiry pgtype.Timestamptz `json:"token_expiry"`
}

// Updates token_id, token_secret, and token_expiry for the main profile avatar (where user_id == file_id)
func (q *Queries) UpdateAvatarTokens(ctx context.Context, arg UpdateAvatarTokensParams) (Avatar, error) {
	row := q.db.QueryRow(ctx, updateAvatarTokens,
		arg.UserID,
		arg.TokenID,
		arg.TokenSecret,
		arg.TokenExpiry,
	)
	var i Avatar
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FileID,
		&i.AvatarType,
		&i.TokenID,
		&i.TokenSecret,
		&i.TokenExpiry,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserProfile = `-- name: UpdateUserProfile :one
UPDATE users SET
    name = COALESCE($2, name),
    bio = COALESCE($3, bio),
    profile_type = COALESCE($4, profile_type)
WHERE id = $1
RETURNING id, name, bio, contacts, profile_type, is_admin_blocked, admin_block_reason, hmac_sha256_hex_username, b64_cipher_chacha20poly1305_username, created_at, updated_at
`

type UpdateUserProfileParams struct {
	ID          uuid.UUID `json:"id"`
	Name        *string   `json:"name"`
	Bio         *string   `json:"bio"`
	ProfileType *string   `json:"profile_type"`
}

// Updates user profile fields conditionally based on provided values (NULL values are ignored)
func (q *Queries) UpdateUserProfile(ctx context.Context, arg UpdateUserProfileParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserProfile,
		arg.ID,
		arg.Name,
		arg.Bio,
		arg.ProfileType,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Bio,
		&i.Contacts,
		&i.ProfileType,
		&i.IsAdminBlocked,
		&i.AdminBlockReason,
		&i.HmacSha256HexUsername,
		&i.B64CipherChacha20poly1305Username,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
